// Copyright 2023-present Eser Ozvataf and other contributors. All rights reserved. Apache-2.0 license.

/**
 * CSS Modules processor with Lightning CSS and optional Tailwind support.
 *
 * Provides utilities for:
 * - Processing .module.css files with scoped styling
 * - Optional Tailwind @apply support via pluggable TailwindRoot
 * - Generating TypeScript .d.ts definitions
 *
 * @module
 */

import * as posix from "@std/path/posix";
import * as fs from "@std/fs";
import type { CssModuleOptions, CssModuleResult } from "./types.ts";
import { transformCssModules } from "./lightning.ts";

/**
 * Process a single CSS module file.
 *
 * @param cssPath - Absolute path to the .module.css file
 * @param options - Processing options
 * @returns Processed CSS module result
 *
 * @example
 * ```ts
 * // Without Tailwind (pure Lightning CSS)
 * const result = await processCssModule("/path/to/button.module.css", {
 *   generateDts: true,
 * });
 * console.log(result.exports); // { container: "container_abc123" }
 *
 * // With Tailwind (@apply support)
 * import { createTailwindRoot } from "@eser/bundler/css/tailwind-plugin";
 * const tailwind = createTailwindRoot({ base: "." });
 * const result = await processCssModule("/path/to/button.module.css", {
 *   tailwind,
 *   generateDts: true,
 * });
 * tailwind.dispose();
 * ```
 */
export async function processCssModule(
  cssPath: string,
  options: CssModuleOptions = {},
): Promise<CssModuleResult> {
  const {
    generateDts = false,
    minify = true,
    targets,
    tailwind,
  } = options;

  // Read CSS file
  let cssContent = await Deno.readTextFile(cssPath);

  // Process with Tailwind first if provided (handles @apply, @tailwind, @theme)
  // This follows the same pattern as @tailwindcss/vite
  if (tailwind !== undefined) {
    const tailwindResult = await tailwind.compile(cssContent, cssPath);
    if (tailwindResult !== null) {
      cssContent = tailwindResult.code;
    }
  }

  // Get filename for scoped class generation
  const filename = posix.basename(cssPath);

  // Process with Lightning CSS for CSS Modules (class scoping)
  const result = transformCssModules(cssContent, filename, {
    minify,
    targets,
    nesting: true,
  });

  // Extract exports mapping (simplified to className: scopedName)
  const exports: Record<string, string> = {};
  if (result.exports !== undefined) {
    for (const [className, exportData] of Object.entries(result.exports)) {
      exports[className] = exportData.name;
    }
  }

  // Generate TypeScript .d.ts if requested
  const dts = generateDts ? generateTypeScriptDefinition(exports) : undefined;

  return {
    code: result.code,
    exports,
    dts,
  };
}

/**
 * Generate TypeScript .d.ts definition for CSS module exports.
 *
 * @param exports - Map of class names to scoped names
 * @returns TypeScript definition content
 */
export function generateTypeScriptDefinition(
  exports: Record<string, string>,
): string {
  const classNames = Object.keys(exports);

  const properties = classNames.map((name) => `  readonly ${name}: string;`)
    .join("\n");

  return `// This file is auto-generated by CSS modules processor
declare const styles: {
${properties}
};

export default styles;
`;
}

/**
 * Process multiple CSS modules in parallel.
 *
 * @param cssPaths - Array of absolute paths to .module.css files
 * @param options - Processing options
 * @returns Map of file paths to processed results
 */
export async function processCssModules(
  cssPaths: readonly string[],
  options: CssModuleOptions = {},
): Promise<Map<string, CssModuleResult>> {
  const results = await Promise.all(
    cssPaths.map(async (cssPath) => {
      const result = await processCssModule(cssPath, options);
      return [cssPath, result] as [string, CssModuleResult];
    }),
  );

  return new Map(results);
}

/**
 * Save CSS module outputs to disk.
 *
 * @param cssPath - Original .module.css path
 * @param result - Processed CSS module result
 * @param outputDir - Directory to save outputs
 * @param baseDir - Base directory for relative path calculation (default: cwd)
 */
export async function saveCssModuleOutputs(
  cssPath: string,
  result: CssModuleResult,
  outputDir: string,
  baseDir?: string,
): Promise<void> {
  const basename = posix.basename(cssPath, ".module.css");
  const relativePath = posix.relative(baseDir ?? Deno.cwd(), cssPath);
  const relativeDir = posix.dirname(relativePath);

  // Create output directory structure mirroring source
  const moduleOutputDir = posix.resolve(outputDir, relativeDir);
  await fs.ensureDir(moduleOutputDir);

  // Save processed CSS
  const cssOutputPath = posix.resolve(
    moduleOutputDir,
    `${basename}.module.css`,
  );
  await Deno.writeTextFile(cssOutputPath, result.code);

  // Save exports JSON
  const jsonOutputPath = posix.resolve(
    moduleOutputDir,
    `${basename}.module.css.json`,
  );
  await Deno.writeTextFile(
    jsonOutputPath,
    JSON.stringify(result.exports, null, 2),
  );

  // Save .d.ts if generated
  if (result.dts !== undefined) {
    const dtsOutputPath = posix.resolve(
      moduleOutputDir,
      `${basename}.module.css.d.ts`,
    );
    await Deno.writeTextFile(dtsOutputPath, result.dts);
  }
}

/**
 * Find all CSS module files in a directory.
 *
 * @param dir - Directory to search
 * @param pattern - Glob pattern (default: "**\/*.module.css")
 * @returns Array of CSS module file paths
 */
export async function findCssModules(
  dir: string,
  pattern: string = "**/*.module.css",
): Promise<string[]> {
  const modules: string[] = [];

  for await (const entry of fs.expandGlob(posix.join(dir, pattern))) {
    if (entry.isFile) {
      modules.push(entry.path);
    }
  }

  return modules;
}

/**
 * Build all CSS modules in a project.
 *
 * @param srcDir - Source directory containing CSS modules
 * @param outputDir - Output directory for processed files
 * @param options - Processing options
 * @returns Map of original paths to results
 */
export async function buildCssModules(
  srcDir: string,
  outputDir: string,
  options: CssModuleOptions = {},
): Promise<Map<string, CssModuleResult>> {
  // Find all CSS modules
  const modulePaths = await findCssModules(srcDir);

  if (modulePaths.length === 0) {
    return new Map();
  }

  // Process all modules
  const results = await processCssModules(modulePaths, options);

  // Save outputs
  for (const [cssPath, result] of results) {
    await saveCssModuleOutputs(cssPath, result, outputDir, srcDir);
  }

  return results;
}

/**
 * Create a CSS modules runtime helper for client-side use.
 *
 * @param exportsMap - Map of module paths to their exports
 * @returns JavaScript code for runtime CSS modules resolution
 */
export function createCssModulesRuntime(
  exportsMap: ReadonlyMap<string, CssModuleResult>,
): string {
  const moduleEntries: string[] = [];

  for (const [path, result] of exportsMap) {
    const relativePath = path.replace(/\.module\.css$/, "");
    moduleEntries.push(
      `  "${relativePath}": ${JSON.stringify(result.exports)}`,
    );
  }

  return `// CSS Modules runtime - auto-generated
const cssModules = {
${moduleEntries.join(",\n")}
};

export function getStyles(modulePath) {
  return cssModules[modulePath] || {};
}

export default cssModules;
`;
}
