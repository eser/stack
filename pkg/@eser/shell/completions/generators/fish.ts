// Copyright 2023-present Eser Ozvataf and other contributors. All rights reserved. Apache-2.0 license.

/**
 * Fish shell completion generator
 *
 * @module
 */

import type { CompletionFlag, CompletionNode } from "../types.ts";

const escapeFish = (str: string): string => {
  return str.replace(/'/g, "\\'");
};

const generateFlagCompletions = (
  appName: string,
  flags: readonly CompletionFlag[],
  condition: string,
): string => {
  let output = "";

  for (const flag of flags) {
    const desc = escapeFish(flag.description ?? `${flag.name} flag`);
    let cmd = `complete -c ${appName} ${condition}`;

    cmd += ` -l ${flag.name}`;
    if (flag.short !== undefined) {
      cmd += ` -s ${flag.short}`;
    }
    if (flag.takesValue === true) {
      cmd += " -r"; // requires argument
    }
    cmd += ` -d '${desc}'`;

    output += cmd + "\n";
  }

  return output;
};

const generateCommandCompletions = (
  appName: string,
  node: CompletionNode,
  path: string[],
): string => {
  let output = "";

  // Build the condition for this level
  let condition: string;
  if (path.length === 0) {
    condition = "-n __fish_use_subcommand";
  } else {
    const pathConditions = path.map((p) => `__fish_seen_subcommand_from ${p}`)
      .join("; and ");
    condition = `-n "${pathConditions}"`;
  }

  // Add subcommand completions
  if (node.children !== undefined && node.children.length > 0) {
    for (const child of node.children) {
      const desc = escapeFish(child.description ?? child.name);

      if (path.length === 0) {
        // Top-level command
        output += `complete -c ${appName} -f ${condition} `;
        output += `-a "${child.name}" -d '${desc}'\n`;
      } else {
        // Nested subcommand - needs to check we're in the right parent
        const parentCondition = `-n "__fish_seen_subcommand_from ${
          path[path.length - 1]
        }"`;
        output += `complete -c ${appName} -f ${parentCondition} `;
        output += `-a "${child.name}" -d '${desc}'\n`;
      }
    }

    // Recurse into children
    for (const child of node.children) {
      output += generateCommandCompletions(appName, child, [
        ...path,
        child.name,
      ]);
    }
  }

  // Add flag completions at this level
  if (node.flags !== undefined && node.flags.length > 0) {
    output += generateFlagCompletions(appName, node.flags, condition);
  }

  return output;
};

/**
 * Generate a fish completion script for the given command tree
 */
export const generate = (appName: string, tree: CompletionNode): string => {
  let output = `# ${appName} fish completion\n`;
  output += `# Generated by @eser/shell/completions\n\n`;

  // Disable file completions for the command
  output += `complete -c ${appName} -f\n\n`;

  output += generateCommandCompletions(appName, tree, []);

  return output;
};
