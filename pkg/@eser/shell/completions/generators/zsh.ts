// Copyright 2023-present Eser Ozvataf and other contributors. All rights reserved. Apache-2.0 license.

/**
 * Zsh shell completion generator
 *
 * @module
 */

import type { CompletionFlag, CompletionNode } from "../types.ts";

const escapeZsh = (str: string): string => {
  return str.replace(/'/g, "'\\''");
};

const generateFlagSpecs = (flags: readonly CompletionFlag[]): string[] => {
  const specs: string[] = [];

  for (const flag of flags) {
    const desc = escapeZsh(flag.description ?? `${flag.name} flag`);
    if (flag.takesValue === true) {
      specs.push(`'--${flag.name}=[${desc}]'`);
      if (flag.short !== undefined) {
        specs.push(`'-${flag.short}=[${desc}]'`);
      }
    } else {
      specs.push(`'--${flag.name}[${desc}]'`);
      if (flag.short !== undefined) {
        specs.push(`'-${flag.short}[${desc}]'`);
      }
    }
  }

  return specs;
};

const generateSubcommandSpecs = (
  children: readonly CompletionNode[],
): string => {
  const specs = children.map((c) => {
    const desc = escapeZsh(c.description ?? c.name);
    return `'${c.name}:${desc}'`;
  });

  return specs.join("\n            ");
};

const generateCommandFunction = (
  appName: string,
  node: CompletionNode,
  path: string[],
): string => {
  const funcName = path.length === 0
    ? `_${appName}`
    : `_${appName}_${path.join("_")}`;

  let output = `${funcName}() {\n`;
  output += `    local -a commands\n`;
  output += `    local -a flags\n\n`;

  // Add flags
  if (node.flags !== undefined && node.flags.length > 0) {
    const flagSpecs = generateFlagSpecs(node.flags);
    output += `    flags=(\n        ${flagSpecs.join("\n        ")}\n    )\n\n`;
  }

  // Add subcommands
  if (node.children !== undefined && node.children.length > 0) {
    output += `    commands=(\n`;
    output += `            ${generateSubcommandSpecs(node.children)}\n`;
    output += `    )\n\n`;

    output += `    _arguments -C \\\n`;
    if (node.flags !== undefined && node.flags.length > 0) {
      output += `        "\${flags[@]}" \\\n`;
    }
    output += `        '1: :->command' \\\n`;
    output += `        '*::arg:->args'\n\n`;

    output += `    case "$state" in\n`;
    output += `        command)\n`;
    output += `            _describe -t commands 'command' commands\n`;
    output += `            ;;\n`;
    output += `        args)\n`;
    output += `            case "\${words[1]}" in\n`;

    for (const child of node.children) {
      const childPath = [...path, child.name];
      const childFunc = `_${appName}_${childPath.join("_")}`;
      output += `                ${child.name})\n`;
      output += `                    ${childFunc}\n`;
      output += `                    ;;\n`;
    }

    output += `            esac\n`;
    output += `            ;;\n`;
    output += `    esac\n`;
  } else if (node.flags !== undefined && node.flags.length > 0) {
    output += `    _arguments "\${flags[@]}"\n`;
  }

  output += `}\n\n`;

  // Generate child functions
  if (node.children !== undefined) {
    for (const child of node.children) {
      output += generateCommandFunction(appName, child, [...path, child.name]);
    }
  }

  return output;
};

/**
 * Generate a zsh completion script for the given command tree
 */
export const generate = (appName: string, tree: CompletionNode): string => {
  let output = `#compdef ${appName}\n`;
  output += `# ${appName} zsh completion\n`;
  output += `# Generated by @eser/shell/completions\n\n`;

  output += generateCommandFunction(appName, tree, []);

  return output;
};
